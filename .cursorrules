# Cursor Rules for Memic Backend

## Code Style Guidelines

### No Emojis in Codebase
- STRICTLY NO EMOJIS in any code files, comments, or strings
- Keep the codebase professional and clean
- Use clear, descriptive text instead of emojis
- This applies to ALL files: Python, Markdown, JSON, YAML, etc.
- Replace emojis with descriptive text (e.g., "Running in DEVELOPMENT mode" not "ðŸ”§ Running in DEVELOPMENT mode")

### Python Code Standards
- Follow PEP 8 style guidelines
- Use type hints where appropriate
- Write clear docstrings for functions and classes
- Use meaningful variable and function names

### FastAPI Best Practices
- Use dependency injection for database sessions
- Implement proper error handling with HTTPException
- Use Pydantic models for request/response validation
- Follow MVC architecture pattern (Controllers â†’ Services â†’ Models â†’ DTOs)

### Project Structure
- Keep controllers thin (HTTP handling only)
- Put business logic in services
- Use DTOs for data validation and serialization
- Keep models focused on database schema

### Environment and Configuration
- Use environment variables for configuration
- Never commit sensitive data to version control
- Use .env files for local development
- Document all required environment variables

## Database Management with Alembic

### STRICT RULES - Database Migrations
- **NEVER** make direct database schema changes
- **NEVER** use `Base.metadata.create_all()` in production code
- **ALWAYS** use Alembic for ALL database schema changes
- **ALL** model changes MUST be accompanied by an Alembic migration

### Alembic Workflow (MANDATORY)
1. **Create Models**: Define or modify SQLAlchemy models in `app/models/`
2. **Generate Migration**: Run `alembic revision --autogenerate -m "description"`
3. **Review Migration**: ALWAYS review the generated migration file before applying
4. **Apply Migration**: Run `alembic upgrade head`
5. **Commit Together**: Commit model changes and migration files together

### Alembic Commands Reference
```bash
# Create a new migration (autogenerate from model changes)
alembic revision --autogenerate -m "descriptive message"

# Create an empty migration (for data migrations or custom changes)
alembic revision -m "descriptive message"

# Apply migrations to the latest version
alembic upgrade head

# Rollback one migration
alembic downgrade -1

# Show current migration version
alembic current

# Show migration history
alembic history

# Show pending migrations
alembic history --verbose
```

### Migration Best Practices
- Write descriptive migration messages (e.g., "add_user_email_verification")
- Always test migrations in development before applying to production
- Keep migrations small and focused on a single change
- Never edit migrations that have been applied to production
- Always implement both `upgrade()` and `downgrade()` functions
- Review autogenerated migrations for accuracy before applying
- For data migrations, use separate migrations from schema changes
- Test rollback functionality (`downgrade()`) before deploying

### Model Changes Checklist
- [ ] Created/modified SQLAlchemy model in `app/models/`
- [ ] Generated Alembic migration: `alembic revision --autogenerate -m "message"`
- [ ] Reviewed generated migration file for accuracy
- [ ] Tested migration: `alembic upgrade head`
- [ ] Tested rollback: `alembic downgrade -1` then `alembic upgrade head`
- [ ] Committed model and migration files together

### Prohibited Actions
- DO NOT use `create_tables()` or `Base.metadata.create_all()` outside of tests
- DO NOT manually create tables using raw SQL
- DO NOT modify database schema through pgAdmin or psql directly
- DO NOT skip migrations for "quick fixes"
- DO NOT delete migration files from the versions directory
- DO NOT modify migration files after they've been applied to any environment

### When Creating New Models
1. Create the model file in `app/models/`
2. Import the model in `app/models/__init__.py`
3. Import the model in `alembic/env.py` (before autogenerate runs)
4. Run `alembic revision --autogenerate -m "add [model_name] model"`
5. Review and apply the migration

## Database Schema Standards

### Timestamp Best Practices
- **ALWAYS** store timestamps in UTC in the database
- Use `DateTime(timezone=True)` for all timestamp columns (creates PostgreSQL TIMESTAMPTZ)
- Use `server_default=func.now()` for auto-setting creation timestamps
- Use `onupdate=func.now()` for auto-updating timestamps on every change
- Never manually set `updated_at` in application code - let SQLAlchemy handle it
- Convert to user's local timezone only at the API/presentation layer
- Database connection is configured with UTC timezone: `connect_args={"options": "-c timezone=utc"}`

### Timestamp Column Template
```python
from sqlalchemy import Column, DateTime
from sqlalchemy.sql import func

created_at = Column(
    DateTime(timezone=True), 
    server_default=func.now(), 
    nullable=False
)
updated_at = Column(
    DateTime(timezone=True), 
    server_default=func.now(), 
    onupdate=func.now(), 
    nullable=False
)
```

### Primary Key Standards
- Use UUID for all primary keys (better for distributed systems and security)
- Use `UUID(as_uuid=True)` with `default=uuid.uuid4` for auto-generation
- Import: `from sqlalchemy.dialects.postgresql import UUID` and `import uuid`

### Foreign Key Standards
- Always specify `ondelete` behavior explicitly
- Use `CASCADE` for dependent entities (e.g., projects under organizations)
- Use `RESTRICT` for referenced entities (e.g., user who created something)
- Add indexes on all foreign key columns for query performance

### Multi-Tenancy Standards
- Each Project is a separate tenant (tenant_id = project_id)
- All RAG data should be scoped to project_id for complete isolation
- User â†’ Organization â†’ Project hierarchy (3-tier like mem0)
- Use UserOrganization table for RBAC with roles: owner, admin, member