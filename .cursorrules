# Cursor Rules for Memic Backend

## Code Style Guidelines

### No Emojis in Codebase
- STRICTLY NO EMOJIS in any code files, comments, or strings
- Keep the codebase professional and clean
- Use clear, descriptive text instead of emojis
- This applies to ALL files: Python, Markdown, JSON, YAML, etc.
- Replace emojis with descriptive text (e.g., "Running in DEVELOPMENT mode" not "ðŸ”§ Running in DEVELOPMENT mode")

### Python Code Standards
- Follow PEP 8 style guidelines
- Use type hints where appropriate
- Write clear docstrings for functions and classes
- Use meaningful variable and function names

### FastAPI Best Practices
- Use dependency injection for database sessions
- Implement proper error handling with HTTPException
- Use Pydantic models for request/response validation
- Follow MVC architecture pattern (Controllers â†’ Services â†’ Models â†’ DTOs)

### Project Structure
- Keep controllers thin (HTTP handling only)
- Put business logic in services
- Use DTOs for data validation and serialization
- Keep models focused on database schema

### Environment and Configuration
- Use environment variables for configuration
- Never commit sensitive data to version control
- Use .env files for local development
- Document all required environment variables

## Database Management with Alembic

### STRICT RULES - Database Migrations
- **NEVER** make direct database schema changes
- **NEVER** use `Base.metadata.create_all()` in production code
- **ALWAYS** use Alembic for ALL database schema changes
- **ALL** model changes MUST be accompanied by an Alembic migration

### Alembic Workflow (MANDATORY)
1. **Create Models**: Define or modify SQLAlchemy models in `app/models/`
2. **Generate Migration**: Run `alembic revision --autogenerate -m "description"`
3. **Review Migration**: ALWAYS review the generated migration file before applying
4. **Apply Migration**: Run `alembic upgrade head`
5. **Commit Together**: Commit model changes and migration files together

### Alembic Commands Reference
```bash
# Create a new migration (autogenerate from model changes)
alembic revision --autogenerate -m "descriptive message"

# Create an empty migration (for data migrations or custom changes)
alembic revision -m "descriptive message"

# Apply migrations to the latest version
alembic upgrade head

# Rollback one migration
alembic downgrade -1

# Show current migration version
alembic current

# Show migration history
alembic history

# Show pending migrations
alembic history --verbose
```

### Migration Best Practices
- Write descriptive migration messages (e.g., "add_user_email_verification")
- Always test migrations in development before applying to production
- Keep migrations small and focused on a single change
- Never edit migrations that have been applied to production
- Always implement both `upgrade()` and `downgrade()` functions
- Review autogenerated migrations for accuracy before applying
- For data migrations, use separate migrations from schema changes
- Test rollback functionality (`downgrade()`) before deploying

### Model Changes Checklist
- [ ] Created/modified SQLAlchemy model in `app/models/`
- [ ] Generated Alembic migration: `alembic revision --autogenerate -m "message"`
- [ ] Reviewed generated migration file for accuracy
- [ ] Tested migration: `alembic upgrade head`
- [ ] Tested rollback: `alembic downgrade -1` then `alembic upgrade head`
- [ ] Committed model and migration files together

### Prohibited Actions
- DO NOT use `create_tables()` or `Base.metadata.create_all()` outside of tests
- DO NOT manually create tables using raw SQL
- DO NOT modify database schema through pgAdmin or psql directly
- DO NOT skip migrations for "quick fixes"
- DO NOT delete migration files from the versions directory
- DO NOT modify migration files after they've been applied to any environment

### When Creating New Models
1. Create the model file in `app/models/`
2. Import the model in `app/models/__init__.py`
3. Import the model in `alembic/env.py` (before autogenerate runs)
4. Run `alembic revision --autogenerate -m "add [model_name] model"`
5. Review and apply the migration

## Database Schema Standards

### Timestamp Best Practices
- **ALWAYS** store timestamps in UTC in the database
- Use `DateTime(timezone=True)` for all timestamp columns (creates PostgreSQL TIMESTAMPTZ)
- Use `server_default=func.now()` for auto-setting creation timestamps
- Use `onupdate=func.now()` for auto-updating timestamps on every change
- Never manually set `updated_at` in application code - let SQLAlchemy handle it
- Convert to user's local timezone only at the API/presentation layer
- Database connection is configured with UTC timezone: `connect_args={"options": "-c timezone=utc"}`

### Timestamp Column Template
```python
from sqlalchemy import Column, DateTime
from sqlalchemy.sql import func

created_at = Column(
    DateTime(timezone=True), 
    server_default=func.now(), 
    nullable=False
)
updated_at = Column(
    DateTime(timezone=True), 
    server_default=func.now(), 
    onupdate=func.now(), 
    nullable=False
)
```

### Primary Key Standards
- Use UUID for all primary keys (better for distributed systems and security)
- Use `UUID(as_uuid=True)` with `default=uuid.uuid4` for auto-generation
- Import: `from sqlalchemy.dialects.postgresql import UUID` and `import uuid`

### Foreign Key Standards
- Always specify `ondelete` behavior explicitly
- Use `CASCADE` for dependent entities (e.g., projects under organizations)
- Use `RESTRICT` for referenced entities (e.g., user who created something)
- Add indexes on all foreign key columns for query performance

### Multi-Tenancy Standards
- Each Project is a separate tenant (tenant_id = project_id)
- All RAG data should be scoped to project_id for complete isolation
- User â†’ Organization â†’ Project hierarchy (3-tier like mem0)
- Use UserOrganization table for RBAC with roles: owner, admin, member

## API Documentation with Postman

### Postman Collection Maintenance (MANDATORY)
- **ALWAYS** update the Postman collection when adding, modifying, or removing API endpoints
- The Postman collection file is located at: `memic-backend.postman_collection.json`
- Keep the collection synchronized with the actual API implementation

### When to Update Postman Collection
1. **New Endpoint Added**: Add corresponding request to appropriate folder in collection
2. **Endpoint Modified**: Update request URL, method, body, or parameters
3. **Endpoint Removed**: Remove the request from collection
4. **New Controller/Module**: Create a new folder in the collection
5. **Response Model Changed**: Update example responses and descriptions

### Postman Collection Update Checklist
- [ ] Added/updated endpoint request in appropriate folder
- [ ] Set correct HTTP method (GET, POST, PUT, DELETE, etc.)
- [ ] Added/updated request body with proper JSON schema
- [ ] Added/updated path parameters and query parameters
- [ ] Configured Bearer token authentication if endpoint requires auth
- [ ] Added clear description explaining what the endpoint does
- [ ] Added test scripts to auto-save important IDs (user_id, org_id, project_id, etc.)
- [ ] Updated collection variables if new IDs need to be tracked
- [ ] Verified the endpoint works by testing in Postman

### Postman Collection Structure
```
memic-backend/
â”œâ”€â”€ Health/
â”œâ”€â”€ Authentication/
â”œâ”€â”€ Users/
â”œâ”€â”€ Organizations/
â”œâ”€â”€ Projects/
â”œâ”€â”€ Members/
â””â”€â”€ [New Module]/  <- Add new folders for new modules
```

### Best Practices for Postman Entries
- Use descriptive names for requests (e.g., "Create Organization" not just "Create")
- Group related endpoints in folders by resource/module
- Use collection variables: `{{base_url}}`, `{{access_token}}`, `{{org_id}}`, `{{project_id}}`, `{{user_id}}`
- Add test scripts to auto-save tokens and IDs from responses
- Include example request bodies with realistic data
- Add comprehensive descriptions for each endpoint
- Keep authentication consistent (Bearer token in Authorization header)

### Auto-Save Script Template
For endpoints that return important IDs or tokens, add this test script:
```javascript
if (pm.response.code === 201 || pm.response.code === 200) {
    const response = pm.response.json();
    pm.collectionVariables.set('variable_name', response.field_name);
    console.log('Variable saved:', response.field_name);
}
```

### Before Merging to Main/Master
- **VERIFY** all API changes are reflected in Postman collection
- **TEST** the updated collection to ensure all requests work
- **COMMIT** Postman collection updates with API code changes
- Postman collection should be ready for team use immediately after merge